<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Roblox Evolution Maze</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1220;
      --accent: #ff3355;
      --text: #eaf2ff;
      --panel: #131a2a;
      --panel2: #0f1626;
      --btn: #ff3355;
      --btnText: #ffffff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 20% 10%, #0f1d3a 0%, #0b1220 60%, #050a16 100%);
      color: var(--text);
      display: grid;
      min-height: 100vh;
      grid-template-rows: auto 1fr auto;
    }
    header {
      padding: 20px;
      background: linear-gradient(180deg, rgba(255,255,255,0.05), transparent);
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    header h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.5px;
    }
    header .subtitle {
      opacity: 0.8;
      font-size: 14px;
      margin-top: 6px;
    }
    main {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 18px;
      padding: 18px;
      align-items: start;
    }
    #stage {
      background: #0a1120;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      position: relative;
      overflow: hidden;
      min-height: 520px;
      display: grid;
      place-items: center;
    }
    #hud {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 14px;
      display: grid;
      gap: 10px;
    }
    #hud h2 { font-size: 16px; margin: 0; }
    .row { display: flex; gap: 10px; align-items: center; }
    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    #info {
      background: var(--panel2);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px;
      font-size: 13px;
      line-height: 1.45;
      max-height: 200px;
      overflow: auto;
      white-space: pre-wrap;
    }
    #controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    button {
      appearance: none;
      background: var(--btn);
      color: var(--btnText);
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.08s ease, filter 0.12s ease;
    }
    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px); }
    #playBtn { font-size: 16px; padding: 12px 18px; }
    canvas {
      width: 100%;
      height: 100%;
      max-width: 880px;
      max-height: 520px;
      border-radius: 12px;
      image-rendering: pixelated; /* retro look */
    }
    footer {
      padding: 16px;
      opacity: 0.75;
      font-size: 12px;
      text-align: center;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(500px 300px at 50% 10%, rgba(255,255,255,0.06), rgba(0,0,0,0.4));
    }
    .card {
      background: rgba(18,26,42,0.85);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      padding: 18px;
      border-radius: 12px;
      max-width: 640px;
      text-align: center;
    }
    .title {
      font-weight: 800; letter-spacing: 0.5px; margin-bottom: 10px;
    }
    .hint { font-size: 13px; opacity: 0.85; margin-top: 6px; }
    .grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    .chip {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 8px;
      border-radius: 10px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <header>
    <h1>ROBLOX Evolution Maze</h1>
    <div class="subtitle">Move through three eras of Roblox avatars and learn how the platform evolved.</div>
  </header>

  <main>
    <section id="stage">
      <canvas id="game" width="880" height="520"></canvas>
      <div id="overlay" class="overlay">
        <div class="card">
          <div class="title">Press Play to Begin</div>
          <div>W A S D or Arrow Keys to move. Reach the goal in each maze to advance eras.</div>
          <div class="grid">
            <div class="chip">2006 • 6‑bit avatar</div>
            <div class="chip">2018 • 16‑bit avatar</div>
            <div class="chip">2025 • Bacon avatar</div>
          </div>
          <div class="hint">Tip: Hug the walls and watch for openings.</div>
          <button id="playBtn">Play</button>
        </div>
      </div>
    </section>

    <aside id="hud">
      <h2>Session</h2>
      <div class="row">
        <span class="badge" id="eraBadge">Era: 2006</span>
        <span class="badge" id="levelBadge">Maze: 1/3</span>
        <span class="badge" id="timeBadge">Time: 00:00</span>
      </div>
      <div id="controls">
        <button id="resetBtn" title="Restart from era 2006">Reset</button>
        <button id="pauseBtn">Pause</button>
      </div>
      <div id="info"></div>
    </aside>
  </main>

  <footer>
    Use W A S D or Arrow Keys to move. Reach the flag to advance. Content auto‑updates as you progress.
  </footer>

  <script>
    // --- Game constants
    const TILE = 40;
    const SPEEDS = { "2006": 2.2, "2018": 2.8, "2025": 3.3 };
    const THEMES = {
      "2006": { wall: "#1b2a41", floor: "#0a1324", avatar: "#a2ff00", detail: 6 },
      "2018": { wall: "#263b66", floor: "#101b33", avatar: "#ffcc00", detail: 16 },
      "2025": { wall: "#2e4a88", floor: "#121f3e", avatar: "#ff3355", detail: 32 } // Bacon vibe
    };

    // --- Narrative text
    const narrativeBase = [
      "Roblox has undergone a remarkable transformation since its launch in 2006.",
      "Originally a simple platform for physics-based games and user-generated content, it evolved into a vast digital ecosystem.",
      "Roblox Studio gave developers powerful tools; shifting from dual currency to Robux streamlined its economy.",
      "Roblox expanded beyond PC to mobile, console, and VR — reaching a global audience.",
      "Today, Roblox is a social and creative hub with virtual concerts, education, and a thriving creator economy.",
      "Developers earn real income, and players explore millions of games across genres.",
      "With over 85 million daily users and major brand partnerships, Roblox reshaped digital interaction."
    ];

    // --- Mazes: 1=2006, 2=2018, 3=2025
    const mazes = [
      {
        era: "2006",
        grid: [
          "###############",
          "#S.....#.....G#",
          "#.###..#..###.#",
          "#...#..#..#...#",
          "###.#..####.#.#",
          "#...#.......#.#",
          "#.#####.#####.#",
          "#.....#.#.....#",
          "###.#.#.#.###.#",
          "#...#...#...#.#",
          "#.#######.#.#.#",
          "#.....#...#...#",
          "#####.#.#####.#",
          "#.....#.......#",
          "###############"
        ]
      },
      {
        era: "2018",
        grid: [
          "####################",
          "#S..#.....#......#G#",
          "#.#.#.###.#.####.#.#",
          "#.#...#...#....#.#.#",
          "#.#####.#####.#.#.#.",
          "#.....#.....#.#...#.",
          "###.#.#.###.#.###.#.",
          "#...#.#...#.#...#.#.",
          "#.###.###.#.###.#.#.",
          "#...#.....#.....#.#.",
          "###.#######.#####.#.",
          "#...#.....#.....#.#.",
          "##.#.#.###.#.###.#.#",
          "#.....#...#.....#..#",
          "####################"
        ]
      },
      {
        era: "2025",
        grid: [
          "########################",
          "#S.....#....#.......#..#",
          "#.###..#.##.#.#######..#",
          "#...#..#....#.....#....#",
          "###.#..######.###.#.####",
          "#...#.......#...#.#....#",
          "#.#####.#####.#.#.####.#",
          "#.....#.#.....#.#....#.#",
          "###.#.#.#.###.#.##.#.#.#",
          "#...#...#...#.#....#.#.#",
          "#.#######.#.#.####.#.#.#",
          "#.....#...#...#..#.#.#.#",
          "#####.#.#####.#.##.#.#.#",
          "#.....#.......#....#...#",
          "#.#############.######.#",
          "#..............#.....#G#",
          "########################"
        ]
      }
    ];

    // --- DOM
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const overlay = document.getElementById("overlay");
    const playBtn = document.getElementById("playBtn");
    const resetBtn = document.getElementById("resetBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const infoEl = document.getElementById("info");
    const eraBadge = document.getElementById("eraBadge");
    const levelBadge = document.getElementById("levelBadge");
    const timeBadge = document.getElementById("timeBadge");

    // --- State
    let currentLevel = 0;
    let pos = { x: 0, y: 0 };
    let vel = { x: 0, y: 0 };
    let started = false;
    let paused = false;
    let startTime = 0;
    let lastTime = 0;

    const keys = new Set();

    // --- Helpers
    function formatTime(ms) {
      const s = Math.floor(ms / 1000);
      const mm = String(Math.floor(s / 60)).padStart(2, "0");
      const ss = String(s % 60).padStart(2, "0");
      return `${mm}:${ss}`;
    }

    function setInfo(lines) {
      infoEl.textContent = lines.join("\n");
    }

    function pushNarrative(era) {
      const prefix =
        era === "2006" ? "Era 2006 • 6‑bit avatar\n" :
        era === "2018" ? "Era 2018 • 16‑bit avatar\n" :
        "Era 2025 • Bacon avatar\n";
      setInfo([prefix, ...narrativeBase]);
    }

    function parseMaze(level) {
      const grid = mazes[level].grid.map(r => r.split(""));
      let start = { x: 1, y: 1 }, goal = { x: 1, y: 1 };
      for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[y].length; x++) {
          if (grid[y][x] === "S") start = { x, y };
          if (grid[y][x] === "G") goal = { x, y };
        }
      }
      return { grid, start, goal };
    }

    let maze = parseMaze(currentLevel);

    function resetLevel(level = 0) {
      currentLevel = level;
      maze = parseMaze(currentLevel);
      const era = mazes[currentLevel].era;
      pos = { x: maze.start.x * TILE + TILE/2, y: maze.start.y * TILE + TILE/2 };
      vel = { x: 0, y: 0 };
      eraBadge.textContent = `Era: ${era}`;
      levelBadge.textContent = `Maze: ${currentLevel + 1}/3`;
      pushNarrative(era);
      draw(0); // immediate draw
    }

    function tileAt(px, py) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (ty < 0 || ty >= maze.grid.length || tx < 0 || tx >= maze.grid[0].length) return "#";
      return maze.grid[ty][tx];
    }

    function collide(nextX, nextY, radius = 12) {
      // Check 4 corners around the avatar circle
      const points = [
        { x: nextX - radius, y: nextY - radius },
        { x: nextX + radius, y: nextY - radius },
        { x: nextX - radius, y: nextY + radius },
        { x: nextX + radius, y: nextY + radius },
      ];
      for (const p of points) {
        if (tileAt(p.x, p.y) === "#") return true;
      }
      return false;
    }

    function handleKeys(dt) {
      const era = mazes[currentLevel].era;
      const speed = SPEEDS[era];
      let dx = 0, dy = 0;
      if (keys.has("ArrowUp") || keys.has("KeyW")) dy -= 1;
      if (keys.has("ArrowDown") || keys.has("KeyS")) dy += 1;
      if (keys.has("ArrowLeft") || keys.has("KeyA")) dx -= 1;
      if (keys.has("ArrowRight") || keys.has("KeyD")) dx += 1;
      if (dx || dy) {
        const len = Math.hypot(dx, dy) || 1;
        vel.x = (dx / len) * speed * TILE * (dt / 1000);
        vel.y = (dy / len) * speed * TILE * (dt / 1000);
      } else {
        vel.x = 0; vel.y = 0;
      }
      const nextX = pos.x + vel.x;
      const nextY = pos.y + vel.y;
      if (!collide(nextX, pos.y)) pos.x = nextX;
      if (!collide(pos.x, nextY)) pos.y = nextY;
    }

    function drawGrid(theme) {
      ctx.fillStyle = theme.floor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < maze.grid.length; y++) {
        for (let x = 0; x < maze.grid[y].length; x++) {
          const tile = maze.grid[y][x];
          const px = x * TILE, py = y * TILE;
          if (tile === "#") {
            ctx.fillStyle = theme.wall;
            ctx.fillRect(px, py, TILE, TILE);
          } else if (tile === "G") {
            // goal flag
            ctx.fillStyle = "#22c55e";
            ctx.fillRect(px + 8, py + 8, TILE - 16, TILE - 16);
            ctx.fillStyle = "#14a34a";
            ctx.fillRect(px + TILE/2 - 2, py + 6, 4, TILE - 12);
            ctx.fillStyle = "#eaffea";
            ctx.beginPath();
            ctx.moveTo(px + TILE/2, py + 10);
            ctx.lineTo(px + TILE/2 + 12, py + 16);
            ctx.lineTo(px + TILE/2, py + 22);
            ctx.closePath();
            ctx.fill();
          }
        }
      }
    }

    function drawAvatar(theme) {
      const { detail } = theme;
      const size = 22 + Math.min(detail, 24) * 0.3;
      // Body (retro pixel-ish blocks)
      ctx.fillStyle = theme.avatar;
      ctx.fillRect(pos.x - size/2, pos.y - size/2, size, size);
      // Face stripe to hint evolution detail
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(pos.x - size/2 + 3, pos.y - size/2 + 6, size - 6, 4);
      // Hair (bacon = reddish streaks in 2025)
      if (detail >= 32) {
        ctx.fillStyle = "#ff667f";
        ctx.fillRect(pos.x - size/2 + 2, pos.y - size/2 + 2, size - 4, 3);
        ctx.fillStyle = "#cc2e48";
        ctx.fillRect(pos.x - size/2 + 2, pos.y - size/2 + 6, size - 4, 3);
      }
      // Shadow
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.beginPath();
      ctx.arc(pos.x, pos.y + size/2, size/2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    function checkGoal() {
      const gx = maze.goal.x * TILE + TILE/2;
      const gy = maze.goal.y * TILE + TILE/2;
      const d = Math.hypot(pos.x - gx, pos.y - gy);
      if (d < 20) {
        // Advance
        if (currentLevel < mazes.length - 1) {
          currentLevel++;
          maze = parseMaze(currentLevel);
          const era = mazes[currentLevel].era;
          pos = { x: maze.start.x * TILE + TILE/2, y: maze.start.y * TILE + TILE/2 };
          pushNarrative(era);
          eraBadge.textContent = `Era: ${era}`;
          levelBadge.textContent = `Maze: ${currentLevel + 1}/3`;
        } else {
          // Completed
          setInfo([
            "You reached the 2025 Bacon avatar finale!",
            "",
            ...narrativeBase,
            "",
            "Thanks for exploring the Roblox evolution. Press Reset to play again."
          ]);
          paused = true;
        }
      }
    }

    function draw(timestamp) {
      const theme = THEMES[mazes[currentLevel].era];
      drawGrid(theme);
      drawAvatar(theme);
      if (started && !paused) {
        checkGoal();
      }
      timeBadge.textContent = `Time: ${formatTime((started && !paused) ? (timestamp - startTime) : (lastTime - startTime))}`;
    }

    function loop(timestamp) {
      if (!started || paused) {
        lastTime = timestamp;
        draw(timestamp);
        requestAnimationFrame(loop);
        return;
      }
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      handleKeys(dt);
      draw(timestamp);
      requestAnimationFrame(loop);
    }

    // --- Events
    window.addEventListener("keydown", (e) => {
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
      keys.add(e.code);
    });
    window.addEventListener("keyup", (e) => {
      keys.delete(e.code);
    });

    playBtn.addEventListener("click", () => {
      overlay.style.display = "none";
      started = true;
      paused = false;
      startTime = performance.now();
    });
    resetBtn.addEventListener("click", () => {
      overlay.style.display = "grid";
      started = false;
      paused = false;
      resetLevel(0);
    });
    pauseBtn.addEventListener("click", () => {
      paused = !paused;
      pauseBtn.textContent = paused ? "Resume" : "Pause";
    });

    // --- Init
    resetLevel(0);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
