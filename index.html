<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Roblox Evolution Maze</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0b1220;
      color: #eaf2ff;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 12px;
      background: #111a33;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    header h1 { margin: 0; font-size: 20px; }
    #stage {
      flex: 1;
      display: grid;
      place-items: center;
      position: relative;
    }
    canvas {
      border-radius: 12px;
      image-rendering: pixelated;
      background: #0a1120;
    }
    #banner {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(18,26,42,0.85);
      border: 1px solid rgba(255,255,255,0.18);
      padding: 8px 14px;
      border-radius: 10px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 1s ease;
      max-width: 80%;
      text-align: center;
    }
    #banner.show { opacity: 1; }
    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,0.5);
    }
    .card {
      background: #1a243f;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      color: #fff;
      max-width: 640px;
    }
    button {
      background: #ff3355;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 10px 14px;
      margin: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    .controls { margin-top: 10px; }
  </style>
</head>
<body>
  <header>
    <h1>Roblox Evolution Maze</h1>
  </header>
  <div id="stage">
    <canvas id="game" width="960" height="560"></canvas>
    <div id="banner"></div>
    <div id="overlay" class="overlay">
      <div class="card">
        <h2>Press Play to Begin</h2>
        <p>
          Use W A S D or Arrow Keys to move.<br>
          Collect keys if required to unlock exits.<br>
          Avoid traps (red circles).<br>
          Press G to regenerate the current maze.
        </p>
        <div class="controls">
          <button id="playBtn">Play</button>
          <button id="resetBtn">Reset</button>
          <button id="pauseBtn">Pause</button>
        </div>
      </div>
    </div>
  </div>
  <script>
    // Canvas & constants
    const TILE = 40;
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const bannerEl = document.getElementById("banner");
    const overlay = document.getElementById("overlay");
    const playBtn = document.getElementById("playBtn");
    const resetBtn = document.getElementById("resetBtn");
    const pauseBtn = document.getElementById("pauseBtn");

    // Themes per era (colors)
    const THEMES = {
      "2006": { wall:"#1b2a41", floor:"#0a1324", avatar:"#a2ff00" },
      "2012": { wall:"#3a1b41", floor:"#1a0a24", avatar:"#00ffff" },
      "2015": { wall:"#224466", floor:"#112233", avatar:"#ff8800" },
      "2016": { wall:"#263b66", floor:"#101b33", avatar:"#ffcc00" },
      "2018": { wall:"#4a2e88", floor:"#1f123e", avatar:"#ff66cc" },
      "2020": { wall:"#2e884a", floor:"#123e1f", avatar:"#66ffcc" },
      "2025": { wall:"#2e4a88", floor:"#121f3e", avatar:"#ff3355" }
    };

    // Era narratives
    const ERA_TEXT = {
      "2006": ["Era 2006 • 6-bit avatar","Roblox launched as a physics sandbox.","Tickets & Robux shaped the early economy."],
      "2012": ["Era 2012 • 8-bit avatar","Badges and improved avatars.","Community events expanded."],
      "2015": ["Era 2015 • 12-bit avatar","DevEx program launched.","Economy matured."],
      "2016": ["Era 2016 • 16-bit avatar","Mobile & console support.","Marketplace boosted creators."],
      "2018": ["Era 2018 • 20-bit avatar","UGC marketplace expanded.","Plugins improved Studio."],
      "2020": ["Era 2020 • 24-bit avatar","Virtual concerts & global events.","Massive growth."],
      "2025": ["Era 2025 • Bacon avatar","VR & brands integrated.","Social hub."]
    };

    // Banner timing
    const BANNER_SHOW_MS = 8000;
    const BANNER_FADE_MS = 1500;

    // Eras list
    const ERAS = ["2006","2012","2015","2016","2018","2020","2025"];

    // Random maze generator (DFS on odd cells)
    function generateMaze(width, height) {
      // Ensure odd dimensions for proper carving
      if (width % 2 === 0) width += 1;
      if (height % 2 === 0) height += 1;
      const grid = Array.from({length:height}, () => Array(width).fill("#"));

      function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

      function carve(cx, cy) {
        const dirs = shuffle([[2,0],[-2,0],[0,2],[0,-2]]);
        for (const [dx, dy] of dirs) {
          const nx = cx + dx, ny = cy + dy;
          if (ny > 0 && ny < height-1 && nx > 0 && nx < width-1 && grid[ny][nx] === "#") {
            grid[ny][nx] = ".";
            grid[cy + dy/2][cx + dx/2] = ".";
            carve(nx, ny);
          }
        }
      }

      // Start and carve
      grid[1][1] = ".";
      carve(1, 1);

      // Place start and goal on open tiles near corners
      grid[1][1] = "S";
      grid[height-2][width-2] = ".";
      // Find nearest open tile to bottom-right for G
      let gx = width-2, gy = height-2;
      for (let y = height-2; y >= 1; y--) {
        for (let x = width-2; x >= 1; x--) {
          if (grid[y][x] === ".") { gx = x; gy = y; y = 0; break; }
        }
      }
      grid[gy][gx] = "G";

      return grid;
    }

    // Sprinkle traps on open floor tiles (avoid start/goal)
    function sprinkleTraps(grid, count = 5) {
      const coords = [];
      for (let y = 1; y < grid.length-1; y++) {
        for (let x = 1; x < grid[y].length-1; x++) {
          if (grid[y][x] === "." ) coords.push([x,y]);
        }
      }
      for (let i = 0; i < Math.min(count, coords.length); i++) {
        const [x,y] = coords[Math.floor(Math.random()*coords.length)];
        // Avoid overwriting start/goal
        if (grid[y][x] === "." ) grid[y][x] = "T";
      }
      return grid;
    }

    // Place a key somewhere reachable (centerish) if required
    function placeKey(grid) {
      // Try center region, fall back to any open tile
      const cy = Math.floor(grid.length/2);
      const cx = Math.floor(grid[0].length/2);
      if (grid[cy][cx] === ".") {
        grid[cy][cx] = "K";
        return grid;
      }
      for (let y = 1; y < grid.length-1; y++) {
        for (let x = 1; x < grid[y].length-1; x++) {
          if (grid[y][x] === ".") { grid[y][x] = "K"; return grid; }
        }
      }
      return grid;
    }

    // Build initial mazes per era
    function buildMazeForEra(eraIndex) {
      const requiresKey = (eraIndex % 2 === 1); // odd-index eras require key
      let grid = generateMaze(21, 15);
      if (requiresKey) grid = placeKey(grid);
      grid = sprinkleTraps(grid, 5);
      return grid;
    }

    const mazes = ERAS.map((era, i) => ({
      era,
      grid: buildMazeForEra(i)
    }));

    // Parse maze for start/goal coords
    function parseMaze(level) {
      const grid = mazes[level].grid;
      let start = {x:1, y:1}, goal = {x:grid[0].length-2, y:grid.length-2};
      for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[y].length; x++) {
          if (grid[y][x] === "S") start = {x, y};
          if (grid[y][x] === "G") goal = {x, y};
        }
      }
      return { grid, start, goal };
    }

    // State
    let currentLevel = 0;
    let maze = parseMaze(currentLevel);
    let pos = { x: maze.start.x*TILE + TILE/2, y: maze.start.y*TILE + TILE/2 };
    let vel = { x:0, y:0 };
    let started = false, paused = false;
    const keysDown = new Set();

    // Banner queue
    let bannerQueue = [];
    let bannerShowing = false;
    let distAcc = 0;
    const DIST_PER_SENTENCE = 120;

    function showBannerOnce(text) {
      bannerShowing = true;
      bannerEl.textContent = text;
      bannerEl.classList.add("show");
      setTimeout(() => {
        bannerEl.classList.remove("show");
        setTimeout(() => { bannerShowing = false; bannerEl.textContent = ""; }, BANNER_FADE_MS);
      }, BANNER_SHOW_MS);
    }

    function startEraBanner() {
      const era = mazes[currentLevel].era;
      bannerQueue = [...ERA_TEXT[era]];
      if (bannerQueue.length) showBannerOnce(bannerQueue.shift());
      distAcc = 0;
    }

    function maybePopBannerByWalk(deltaDist) {
      if (!started || paused) return;
      distAcc += deltaDist;
      if (bannerShowing) return;
      if (bannerQueue.length === 0) return;
      if (distAcc >= DIST_PER_SENTENCE) {
        distAcc = 0;
        showBannerOnce(bannerQueue.shift());
      }
    }

    // Collision helpers
    function tileAt(px, py) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (ty < 0 || ty >= maze.grid.length || tx < 0 || tx >= maze.grid[0].length) return "#";
      return maze.grid[ty][tx];
    }

    function collide(nextX, nextY, radius = 12) {
      const points = [
        { x: nextX - radius, y: nextY - radius },
        { x: nextX + radius, y: nextY - radius },
        { x: nextX - radius, y: nextY + radius },
        { x: nextX + radius, y: nextY + radius },
      ];
      for (const p of points) {
        if (tileAt(p.x, p.y) === "#") return true;
      }
      return false;
    }

    // Movement
    function handleKeys(dt) {
      const era = mazes[currentLevel].era;
      const speed = 2.6; // uniform speed across eras for consistency
      let dx = 0, dy = 0;
      if (keysDown.has("ArrowUp") || keysDown.has("KeyW")) dy -= 1;
      if (keysDown.has("ArrowDown") || keysDown.has("KeyS")) dy += 1;
      if (keysDown.has("ArrowLeft") || keysDown.has("KeyA")) dx -= 1;
      if (keysDown.has("ArrowRight") || keysDown.has("KeyD")) dx += 1;

      const prevX = pos.x, prevY = pos.y;

      if (dx || dy) {
        const len = Math.hypot(dx, dy) || 1;
        vel.x = (dx / len) * speed * TILE * (dt / 1000);
        vel.y = (dy / len) * speed * TILE * (dt / 1000);
      } else {
        vel.x = 0; vel.y = 0;
      }

      const nextX = pos.x + vel.x;
      const nextY = pos.y + vel.y;

      if (!collide(nextX, pos.y)) pos.x = nextX;
      if (!collide(pos.x, nextY)) pos.y = nextY;

      const deltaDist = Math.hypot(pos.x - prevX, pos.y - prevY);
      if (deltaDist > 0) maybePopBannerByWalk(deltaDist);
    }

    // Traps & key logic
    let hasKey = false;

    function checkSpecialTiles() {
      const tx = Math.floor(pos.x / TILE);
      const ty = Math.floor(pos.y / TILE);
      const tile = maze.grid[ty][tx];

      if (tile === "T") {
        showBannerOnce("You hit a trap! Back to start.");
        pos = { x: maze.start.x*TILE + TILE/2, y: maze.start.y*TILE + TILE/2 };
        return;
      }

      if (tile === "K") {
        hasKey = true;
        maze.grid[ty][tx] = "."; // remove key after pickup
        showBannerOnce("You found the key! The exit is now open.");
        return;
      }

      if (tile === "G") {
        // If this era requires a key, enforce it
        const requiresKey = (currentLevel % 2 === 1);
        if (requiresKey && !hasKey) {
          showBannerOnce("The exit is locked. Find the key!");
          // Nudge player away from the goal tile to avoid camping
          pos.y -= 6;
          return;
        }
        // Advance to next era or finish
        if (currentLevel < mazes.length - 1) {
          currentLevel++;
          hasKey = false;
          maze = parseMaze(currentLevel);
          pos = { x: maze.start.x*TILE + TILE/2, y: maze.start.y*TILE + TILE/2 };
          startEraBanner();
          showBannerOnce(`Advancing to ${mazes[currentLevel].era}`);
        } else {
          showBannerOnce("Finale reached! Thanks for exploring the Roblox evolution.");
          paused = true;
          overlay.style.display = "grid";
        }
      }
    }

    // Drawing
    function drawGrid(theme) {
      ctx.fillStyle = theme.floor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < maze.grid.length; y++) {
        for (let x = 0; x < maze.grid[y].length; x++) {
          const tile = maze.grid[y][x];
          const px = x * TILE, py = y * TILE;

          if (tile === "#") {
            ctx.fillStyle = theme.wall;
            ctx.fillRect(px, py, TILE, TILE);
          } else if (tile === "G") {
            // goal flag
            ctx.fillStyle = "#22c55e";
            ctx.fillRect(px + 8, py + 8, TILE - 16, TILE - 16);
          } else if (tile === "K") {
            // key
            ctx.fillStyle = "#ffaa00";
            ctx.fillRect(px + 12, py + 12, TILE - 24, TILE - 24);
          } else if (tile === "T") {
            // trap
            ctx.fillStyle = "#ff3333";
            ctx.beginPath();
            ctx.arc(px + TILE/2, py + TILE/2, TILE/3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
    }

    function drawAvatar(theme) {
      const size = 24;
      ctx.fillStyle = theme.avatar;
      ctx.fillRect(pos.x - size/2, pos.y - size/2, size, size);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(pos.x - size/2 + 3, pos.y - size/2 + 6, size - 6, 4);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.beginPath();
      ctx.arc(pos.x, pos.y + size/2, size/2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    function draw() {
      const theme = THEMES[mazes[currentLevel].era];
      drawGrid(theme);
      drawAvatar(theme);
    }

    // Main loop
    let lastTime = 0;
    function loop(timestamp) {
      if (!started || paused) {
        lastTime = timestamp;
        draw();
        requestAnimationFrame(loop);
        return;
      }
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      handleKeys(dt);
      checkSpecialTiles();
      draw();
      requestAnimationFrame(loop);
    }

    // Events
    window.addEventListener("keydown", (e) => {
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
      keysDown.add(e.code);

      // G = regenerate current maze (brand-new)
      if (e.code === "KeyG") {
        const eraIndex = currentLevel;
        mazes[eraIndex].grid = buildMazeForEra(eraIndex);
        maze = parseMaze(currentLevel);
        hasKey = false;
        pos = { x: maze.start.x*TILE + TILE/2, y: maze.start.y*TILE + TILE/2 };
        showBannerOnce("New maze generated with G key.");
      }
    });
    window.addEventListener("keyup", (e) => { keysDown.delete(e.code); });

    playBtn.addEventListener("click", () => {
      overlay.style.display = "none";
      started = true;
      paused = false;
      startEraBanner();
    });
    resetBtn.addEventListener("click", () => {
      overlay.style.display = "grid";
      started = false;
      paused = false;
      currentLevel = 0;
      hasKey = false;
      maze = parseMaze(currentLevel);
      pos = { x: maze.start.x*TILE + TILE/2, y: maze.start.y*TILE + TILE/2 };
      startEraBanner();
    });
    pauseBtn.addEventListener("click", () => {
      paused = !paused;
      pauseBtn.textContent = paused ? "Resume" : "Pause";
    });

    // Init
    startEraBanner();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
